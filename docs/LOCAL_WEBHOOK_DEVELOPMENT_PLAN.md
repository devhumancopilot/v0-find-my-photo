# Local Webhook Development Plan

## Overview

**Goal:** Replace N8N webhooks with local Next.js API routes for development, while keeping N8N as an option for production.

**Strategy:** Create parallel dev webhook handlers that replicate N8N workflow logic, with environment-based routing to switch between local and N8N.

---

## Architecture

### Current Flow (Production)
\`\`\`
Frontend → /api/webhooks/* → triggerWebhook() → N8N → Supabase
\`\`\`

### New Flow (Development)
\`\`\`
Frontend → /api/webhooks/* → triggerWebhook() → /api/dev-webhooks/* → Supabase
                                     ↓ (checks USE_LOCAL_WEBHOOKS)
                                     └→ N8N (if false)
\`\`\`

---

## Confirmed Configuration Details

### Supabase Storage
- **Bucket:** `photos`
- **Path Pattern:** `uploads/{sanitized_filename}{sanitized_user_id}`
- **Method:** Direct HTTP POST with binary data
- **Content-Type:** `application/octet-stream`
- **Filename Sanitization:** `replace(/[^a-zA-Z0-9-_]/g, '_')`

### OpenAI Configuration
- **Vision Model:** `gpt-4o`
- **Detail Level:** `low`
- **Embedding Model:** `text-embedding-3-small` (1536 dimensions)
- **Image Analysis Prompt:**
  \`\`\`
  Identify and describe what is shown in this image using short, factual tags.
  Focus on the main subject, scene type, and any relevant small details such as
  activity, setting, or type of object. Avoid abstract concepts, emotions, or
  artistic interpretation. Use simple, direct language — for example: 'red sports
  car, Ferrari, parked on street' or 'family dinner at home, parents and children
  eating together.
  \`\`\`

### Database Schema

#### Photos Table
\`\`\`sql
CREATE TABLE public.photos (
  id bigserial PRIMARY KEY,
  name text NOT NULL,
  file_url text,
  type text,
  size numeric,
  caption text,
  embedding vector,  -- pgvector (1536 dimensions)
  created_at timestamp DEFAULT now(),
  data text,  -- Base64 (optional - configurable)
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  album_id bigint REFERENCES public.albums(id) ON DELETE CASCADE,
  position integer DEFAULT 0,
  metadata jsonb,
  thumbnail_url text,
  updated_at timestamptz DEFAULT now()
);
\`\`\`

#### Albums Table
\`\`\`sql
CREATE TABLE public.albums (
  id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  created_at timestamptz NOT NULL DEFAULT now(),
  album_title text,
  photos text[],  -- Array of photo IDs
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  description text,
  cover_image_url text,
  photo_count integer DEFAULT 0,
  status text DEFAULT 'active',
  processing_status text DEFAULT 'completed',
  updated_at timestamptz DEFAULT now()
);
\`\`\`

#### Existing Supabase Function
\`\`\`sql
-- Vector similarity search function (already exists)
create or replace function match_photos (
  query_embedding vector(1536),
  match_count int default null,
  filter jsonb default '{}'
)
returns table (
  id bigint,
  name text,
  file_url text,
  caption text,
  similarity float
)
language plpgsql
as $$
#variable_conflict use_column
begin
  return query
  select
    p.id,
    p.name,
    p.file_url,
    p.caption,
    1 - (p.embedding <=> query_embedding) as similarity
  from public.photos p
  where
    (filter = '{}' or to_jsonb(p) @> filter)
  order by p.embedding <=> query_embedding
  limit match_count;
end;
$$;
\`\`\`

---

## File Structure

\`\`\`
lib/services/              (NEW - Service layer)
├── openai.ts             → Image captioning + embeddings
├── storage.ts            → Supabase Storage uploads
└── database.ts           → DB operations (insert photos, match_photos, albums)

app/api/dev-webhooks/     (NEW - Local webhook handlers)
├── photos-upload/
│   └── route.ts          → Replaces N8N manual upload workflow
├── find-photos/
│   └── route.ts          → Replaces N8N semantic search workflow
└── album-finalized/
    └── route.ts          → Replaces N8N album creation workflow

lib/webhooks.ts           (MODIFY - Add routing logic)
.env.local                (MODIFY - Add new variables)
\`\`\`

---

## Implementation Details

### Phase 1: Service Layer (lib/services/)

#### 1. `openai.ts` - OpenAI API Wrapper

**Functions:**

\`\`\`typescript
generateImageCaption(base64: string, mimeType: string): Promise<string>
\`\`\`
- Uses GPT-4O with detail="low"
- Applies exact N8N prompt (factual tags, no emotions)
- Returns caption string

\`\`\`typescript
generateTextEmbedding(text: string): Promise<number[]>
\`\`\`
- Uses text-embedding-3-small
- Returns number[] (1536 dimensions)

\`\`\`typescript
generateImageEmbedding(base64: string, mimeType: string): Promise<number[]>
\`\`\`
- Generates caption first, then embeds the caption
- Used for image-based search queries
- Returns number[] (1536 dimensions)

---

#### 2. `storage.ts` - Supabase Storage Operations

**Functions:**

\`\`\`typescript
uploadPhotoToStorage(
  base64: string,
  userId: string,
  filename: string,
  mimeType: string
): Promise<string>
\`\`\`

**Implementation:**
1. Sanitize filename: `replace(/[^a-zA-Z0-9-_]/g, '_')`
2. Sanitize userId: `replace(/[^a-zA-Z0-9-_]/g, '_')`
3. Build path: `uploads/{sanitized_name}{sanitized_user_id}`
4. Convert base64 → Buffer
5. POST to: `https://xtarrhnroghlnyiaxsrd.supabase.co/storage/v1/object/photos/{path}`
6. Headers:
   - `apikey`: Supabase anon key
   - `authorization`: Bearer {service_role_key}
   - `content-type`: `application/octet-stream`
7. Returns: Public file URL

---

#### 3. `database.ts` - Database Operations

**Functions:**

\`\`\`typescript
insertPhoto(photoData: PhotoInsertData): Promise<number>
\`\`\`
- Inserts into `public.photos`
- Fields: name, file_url, type, size, caption, embedding, user_id
- Optional: data (base64) - controlled by `STORE_BASE64_IN_DB` env var
- Returns: Inserted photo ID

\`\`\`typescript
matchPhotos(
  embedding: number[],
  userId: string,
  matchCount: number = 20
): Promise<MatchedPhoto[]>
\`\`\`
- Calls `supabase.rpc('match_photos', { query_embedding, match_count, filter })`
- Filter by `user_id` automatically (ensures user isolation)
- Returns: `{ id, name, file_url, caption, similarity }[]`

\`\`\`typescript
createAlbum(
  albumData: AlbumData,
  photoIds: string[],
  userId: string
): Promise<number>
\`\`\`
- Inserts into `public.albums`
- Fields: album_title, description, cover_image_url, photos, user_id, photo_count
- Returns: Created album ID

---

### Phase 2: Dev Webhook Handlers (app/api/dev-webhooks/)

#### 1. `photos-upload/route.ts` - Photo Upload Handler

**Endpoint:** `POST /api/dev-webhooks/photos-upload`

**Request Body:**
\`\`\`typescript
{
  user_id: string,
  images: Array<{
    name: string,
    data: string,  // base64
    type: string,  // MIME type
    size: number
  }>,
  timestamp: string
}
\`\`\`

**Flow:**
1. Validate authentication (check user_id matches session)
2. For each image (process sequentially to avoid rate limits):
   - a. `generateImageCaption(data, type)` → caption
   - b. `uploadPhotoToStorage(data, user_id, name, type)` → file_url
   - c. `generateTextEmbedding(caption)` → embedding
   - d. `insertPhoto({name, file_url, type, size, caption, embedding, user_id, data?})` → photo_id
3. Return: `{ success: true, processed_count, photo_ids }`

**Error Handling:**
- OpenAI fails: Log error, return 500
- Storage fails: Log error, skip to next image
- DB fails: Log error, return 500
- Return detailed error messages in dev mode

---

#### 2. `find-photos/route.ts` - Semantic Search Handler

**Endpoint:** `POST /api/dev-webhooks/find-photos`

**Request Body:**
\`\`\`typescript
{
  user_id: string,
  query: {
    text?: string,      // Text query
    image?: string      // Base64 image query
  },
  match_count?: number  // Default: 20
}
\`\`\`

**Flow:**
1. Validate authentication
2. Generate embedding:
   - If `query.text` exists: `generateTextEmbedding(query.text)`
   - Else if `query.image` exists: `generateImageEmbedding(query.image)`
3. Call `matchPhotos(embedding, user_id, match_count || 20)`
4. Return: `{ photos: [...], count }`

**Response:**
\`\`\`typescript
{
  photos: Array<{
    id: number,
    name: string,
    file_url: string,
    caption: string,
    similarity: number
  }>,
  count: number
}
\`\`\`

---

#### 3. `album-finalized/route.ts` - Album Creation Handler

**Endpoint:** `POST /api/dev-webhooks/album-finalized`

**Request Body:**
\`\`\`typescript
{
  user_id: string,
  album_title: string,
  description: string,
  photo_ids: string[],
  cover_photo_id: string
}
\`\`\`

**Flow:**
1. Validate authentication
2. Get cover photo URL (query photos table by cover_photo_id)
3. `createAlbum({album_title, description, cover_image_url, photos: photo_ids, user_id, photo_count})`
4. Return: `{ success: true, album_id }`

**Response:**
\`\`\`typescript
{
  success: boolean,
  album_id: number
}
\`\`\`

---

### Phase 3: Webhook Router (lib/webhooks.ts)

**Update existing `triggerWebhook()` function:**

\`\`\`typescript
export async function triggerWebhook(
  webhookUrl: string,
  payload: any
): Promise<{ success: boolean; error: string | null }> {
  const useLocal = process.env.USE_LOCAL_WEBHOOKS === 'true'

  if (useLocal) {
    // Map N8N URLs to local endpoints
    const localUrl = mapToLocalWebhook(webhookUrl)
    const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'

    const response = await fetch(`${baseUrl}${localUrl}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    })

    return {
      success: response.ok,
      error: response.ok ? null : await response.text()
    }
  } else {
    // Use N8N (production)
    const response = await fetch(webhookUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    })

    return {
      success: response.ok,
      error: response.ok ? null : await response.text()
    }
  }
}

function mapToLocalWebhook(n8nUrl: string): string {
  const mapping: Record<string, string> = {
    [process.env.N8N_WEBHOOK_MANUAL_IMAGE_UPLOAD!]: '/api/dev-webhooks/photos-upload',
    [process.env.N8N_WEBHOOK_FIND_PHOTOS!]: '/api/dev-webhooks/find-photos',
    [process.env.N8N_WEBHOOK_ALBUM_FINALIZED!]: '/api/dev-webhooks/album-finalized',
  }

  const localPath = mapping[n8nUrl]
  if (!localPath) {
    throw new Error(`Unknown webhook URL: ${n8nUrl}`)
  }

  return localPath
}
\`\`\`

---

### Phase 4: Environment Configuration

**Add to `.env.local`:**

\`\`\`bash
# =============================================================================
# LOCAL WEBHOOK DEVELOPMENT
# =============================================================================
# Set to 'true' to use local webhook handlers instead of N8N
# Set to 'false' to use N8N webhooks (production mode)
USE_LOCAL_WEBHOOKS=true

# OpenAI API Configuration
# Required for image captioning and embeddings
OPENAI_API_KEY=sk-...

# Optional: Store base64 in database (increases DB size significantly)
# Set to 'true' if you need to keep base64 data in the photos.data column
# Set to 'false' to save database space (recommended)
STORE_BASE64_IN_DB=false

# App URL for local webhook routing
# Use localhost for development, update for production
NEXT_PUBLIC_APP_URL=http://localhost:3000
\`\`\`

---

## Implementation Strategy

### Recommended Order

1. ✅ Check if `openai` package is installed (`npm list openai`)
   - If not: `npm install openai`

2. Build service layer (bottom-up):
   - `lib/services/openai.ts` (core AI functionality)
   - `lib/services/storage.ts` (Supabase storage)
   - `lib/services/database.ts` (DB operations)

3. Build webhook handlers (depends on services):
   - `app/api/dev-webhooks/photos-upload/route.ts` (most complex)
   - `app/api/dev-webhooks/find-photos/route.ts` (simpler)
   - `app/api/dev-webhooks/album-finalized/route.ts` (simplest)

4. Update webhook router:
   - Modify `lib/webhooks.ts` with environment-based routing

5. Configure environment:
   - Add new variables to `.env.local`

6. Test each flow individually:
   - Photo upload → verify caption, embedding, storage, DB insert
   - Semantic search → verify embedding generation and matching
   - Album creation → verify album creation and photo linking

---

## Workflow Comparison

### N8N Workflow 1: Manual Image Upload

**Current N8N Steps:**
1. Webhook receives image (base64)
2. Convert base64 to binary (redundant!)
3. Send to OpenAI for caption
4. Upload to Supabase Storage
5. Generate embedding from caption
6. Store all data in database

**New Backend Steps:**
1. Receive base64 image (already in format)
2. Generate caption via OpenAI GPT-4O
3. Upload to Supabase Storage (directly from base64)
4. Generate embedding from caption
5. Store in database (single operation)

**Eliminated Steps:**
- ❌ Base64 ↔ Binary conversions
- ❌ Multiple data passing between nodes
- ✅ Direct API calls

---

### N8N Workflow 2: Semantic Search (Find Photos)

**Current N8N Steps:**
1. Receive query (text or image)
2. Generate embedding
3. Call `match_photos()` function
4. Return results

**New Backend Steps:**
1. Receive query
2. Generate embedding
3. Call `match_photos()` via RPC
4. Return results

**Note:** This workflow is already optimal - minimal changes needed.

---

### N8N Workflow 3: Album Finalization

**Current N8N Steps:**
1. Receive album data
2. Insert into albums table
3. Return success

**New Backend Steps:**
1. Receive album data
2. Get cover photo URL
3. Insert into albums table
4. Return success

**Note:** Simple DB insert - straightforward implementation.

---

## Key Decisions Made

1. **Base64 Storage:**
   - Make it **optional** via `STORE_BASE64_IN_DB` environment variable
   - Default: `false` (save database space)
   - Set to `true` only if needed for debugging or other purposes

2. **Error Handling:**
   - Log all errors to console with detailed context
   - Return detailed error responses in dev mode
   - Return generic errors in production mode

3. **Filename Sanitization:**
   - Match N8N logic exactly: `replace(/[^a-zA-Z0-9-_]/g, '_')`
   - Apply to both filename and user_id

4. **Image Processing:**
   - Process images **sequentially** (not parallel) to avoid OpenAI rate limits
   - Log progress for each image

5. **Storage Path:**
   - Exact match to N8N: `uploads/{sanitized_name}{sanitized_user_id}`

6. **Authentication:**
   - Validate user session in all webhook handlers
   - Ensure user_id from payload matches authenticated user

---

## Testing Checklist

### Photo Upload Flow
- [ ] Single image upload works
- [ ] Multiple image upload works
- [ ] Caption is generated correctly
- [ ] Image is stored in Supabase Storage
- [ ] Embedding is generated (1536 dimensions)
- [ ] Photo record is created in database
- [ ] Base64 storage respects `STORE_BASE64_IN_DB` setting
- [ ] Error handling works (OpenAI fails, storage fails, etc.)

### Semantic Search Flow
- [ ] Text query search works
- [ ] Image query search works
- [ ] Results are filtered by user_id
- [ ] Similarity scores are returned correctly
- [ ] Match count parameter works
- [ ] No cross-user data leakage

### Album Creation Flow
- [ ] Album is created in database
- [ ] Photo IDs are stored correctly
- [ ] Cover photo URL is retrieved
- [ ] Photo count is calculated correctly
- [ ] User_id is set correctly

### Integration Testing
- [ ] Complete flow: Upload → Search → Create Album
- [ ] Switch between local and N8N via `USE_LOCAL_WEBHOOKS`
- [ ] Environment variables are loaded correctly
- [ ] No breaking changes to existing functionality

---

## Benefits

✅ **Faster iteration** - No external N8N dependency
✅ **Better debugging** - Full visibility into processing
✅ **Cost savings** - Avoid N8N hosting costs during development
✅ **Offline development** - Work without internet (with local models)
✅ **Production unchanged** - Keep N8N for prod, local for dev
✅ **Easy toggle** - Single env var to switch between modes
✅ **Reduced complexity** - Eliminate redundant data conversions

---

## Notes

- The existing `/api/webhooks/*` endpoints remain unchanged
- Frontend code requires no modifications
- All changes are backend-only
- N8N workflows can still be used in production
- Local development is completely self-contained
- Ensure `OPENAI_API_KEY` is valid and has sufficient credits

---

## Future Enhancements

- Add retry logic for failed OpenAI calls
- Implement batch processing for multiple images
- Add progress tracking for long uploads
- Cache embeddings for duplicate images
- Add thumbnail generation
- Implement image optimization before storage
- Add support for local embedding models (offline development)

---

## References

- OpenAI API Docs: https://platform.openai.com/docs/api-reference
- Supabase Storage API: https://supabase.com/docs/reference/javascript/storage
- pgvector Documentation: https://github.com/pgvector/pgvector
- N8N Webhook Integration Docs: `./N8N_WEBHOOK_INTEGRATION.md`
- Database Migration Guide: `./MIGRATION_GUIDE.md`
